<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".html" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="UserInterface_v1_0.ttinclude" #>
<#   
	// Set abstraction specific type and single file specific extension
	TransformGenerator< UserInterfaceAbstractionType >(GenerateRoot, ".designer.html");	
	//GenerateRoot();
#>
<#+ 
/*
	public Tuple<string, string>[] GetGeneratorContent(params string[] xmlFileNames)
	{
		List<Tuple<string, string>> result = new List<Tuple<string, string>>();
		foreach(string xmlFileName in xmlFileNames)
		{
			ClassModelAbstractionType abs = LoadXml<ClassModelAbstractionType>(xmlFileName);
			CurrentAbstraction = abs;
			string content = TransformText();
			string outputFile = Path.GetFileNameWithoutExtension(xmlFileName) + ".designer.js";
			result.Add(Tuple.Create(outputFile, content));
		}
		return result.ToArray();
	}
*/	
	void SetCurrentAbstraction(object abs)
	{
		CurrentAbstraction = ( UserInterfaceAbstractionType ) abs;
	}
	
	UserInterfaceAbstractionType CurrentAbstraction;
	
	void GenerateRoot()
	{
		GenerateAbstraction(CurrentAbstraction);
	}
	
	void GenerateAbstraction(UserInterfaceAbstractionType abstraction)
	{
		foreach(var userInterface in abstraction.UserInterfaces) {
			foreach(ViewType view in userInterface.Views)
				GenerateView(view);
		}
	}
	
	void GenerateView(ViewType view)
	{
		string viewName = view.name;
		#>
<html>
<body>
<div name="<#= viewName #>">
<#+
		foreach(var viewItem in view.Items)
			GenerateViewItem(viewItem);
#>
</div>
</body>
</html>		
		<#+
	}
	
	void GenerateChildView(ChildViewType childView)
	{
#>
<#+
	}
	
	void GenerateNumeric(NumericType numeric)
	{
		
#>
<textarea>Numeric data here</textarea>
<#+
	}
	
	void GenerateString(StringType stringType)
	{
#>
<textarea>String data here</textarea>
<#+
	}
	
	void GenerateAttachmentBlob(AttachmentBlobType attachmentBlob)
	{
#>
<img>Attachmen data here for type: <#= attachmentBlob.mediaType.ToString() #></img>
<#+
	}
	
	void GenerateViewProperty(ViewPropertyType viewProp)
	{
		string labelText = viewProp.LabelText;
		string vpid = viewProp.name;
#>
<label><#= labelText #></label>
<div viewpropid="<#= vpid #>">
<#+
		switch(viewProp.ItemElementName)
		{
			case ItemChoiceType1.Numeric:
				GenerateNumeric(viewProp.Item as NumericType);
				break;
			case ItemChoiceType1.String:
				GenerateString(viewProp.Item as StringType);
				break;
			case ItemChoiceType1.AttachmentBlob:
				GenerateAttachmentBlob(viewProp.Item as AttachmentBlobType);
				break;
		}
#>
</div>
<#+
	}
	
	void GenerateViewItem(object viewItem)
	{
		ChildViewType childView = viewItem as ChildViewType;
		ViewPropertyType viewProp = viewItem as ViewPropertyType;
		if(childView != null)
			GenerateChildView(childView);
		else if(viewProp != null)
			GenerateViewProperty(viewProp);
		else
			throw new NotSupportedException("Unsupported view item type: " + viewItem.GetType().Name);
	}
	
	void GenerateProperty(PropertyType prop)
	{
		string label = prop.LabelText;
		StringType strItem = (StringType) prop.Item;
		string className = "str" + strItem.minLength + "-" + strItem.maxLength; 
		string strContent = prop.name;
		#>
		<div class="label"><#= label #></div><div class="<#= className #>">
		<input><#= strContent #></input></div>
		<#+
	}
	
#>